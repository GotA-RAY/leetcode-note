## [13. 罗马数字转整数](https://leetcode.cn/problems/roman-to-integer/)

罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。

```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

例如， 罗马数字 `2` 写做 `II` ，即为两个并列的 1 。`12` 写做 `XII` ，即为 `X` + `II` 。 `27` 写做 `XXVII`, 即为 `XX` + `V` + `II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 
- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。

 

**示例 1:**

```
输入: s = "III"
输出: 3
```

**示例 2:**

```
输入: s = "IV"
输出: 4
```

**示例 3:**

```
输入: s = "IX"
输出: 9
```

**示例 4:**

```
输入: s = "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.
```

**示例 5:**

```
输入: s = "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```

 

**提示：**

- `1 <= s.length <= 15`
- `s` 仅含字符 `('I', 'V', 'X', 'L', 'C', 'D', 'M')`
- 题目数据保证 `s` 是一个有效的罗马数字，且表示整数在范围 `[1, 3999]` 内
- 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。
- IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。
- 关于罗马数字的详尽书写规则，可以参考 [罗马数字 - Mathematics ](https://b2b.partcommunity.com/community/knowledge/zh_CN/detail/10753/罗马数字#knowledge_article)。



罗马数字转换，其实搞懂他的规律就好了

大的数字会排到小的数字前面

有一种情况例外，就是 4 ，9，40 ，90，400，900 ... 这类数字

他们是小的在大的前面，这个小的呢是相对小的，新的字母减该上一个数量级代表的最大的字母

5 V 他的上一级数量级是1 那么4 IV 就是小的在左边大的在右边，再比如9 IX ,X 10 上一个数量级1 I

40 XL L 50 上一级数量级最大的就是10了

所以我们解法按照这个来

从头遍历到尾

先将代表的数字累加到ans，

记得如果该字母前面字母的话，记得比较一下两个字母代表数字的大小，如果上一个字母比当前字母代表的数字小的，就减去刚刚加上的字母代表的数字的两倍，应为本来就是减去的，我加上了，后面发现了肯定要再减去一次的

```
class Solution {
public:
    int transfer(char ch)
    {
        int res = 0;
        if(ch == 'I')
        {
            res = 1;
        }
        else if(ch == 'V')
        {
            res = 5;
        }
        else if(ch == 'X')
        {
            res =  10;
        }
        else if(ch == 'L')
        {
            res =  50;
        }
        else if(ch == 'C')
        {
            res =  100;
        }
        else if(ch == 'D')
        {
            res =  500;
        }
        else if(ch == 'M')
        {
            res =  1000;
        }
        return res;

        //字符          数值
        //I             1
        //V             5
        //X             10
        //L             50
        //C             100
        //D             500
        //M             1000
    }
    int romanToInt(string s) {
        int ans = 0;
        int cur = 0;
        int pre = 0;
        int n = s.size();
        for(int i = 0;i < n;i++)
        {
            cur = transfer(s[i]);
            ans+=cur;
            if(i>0)
            {
                pre = transfer(s[i-1]);
                if(pre < cur)
                ans -= pre*2;
            }
           
        }
        return ans;
    }
};
```



## [12. 整数转罗马数字](https://leetcode.cn/problems/integer-to-roman/)

已解答

中等



相关标签

相关企业



七个不同的符号代表罗马数字，其值如下：

| 符号 | 值   |
| ---- | ---- |
| I    | 1    |
| V    | 5    |
| X    | 10   |
| L    | 50   |
| C    | 100  |
| D    | 500  |
| M    | 1000 |

罗马数字是通过添加从最高到最低的小数位值的转换而形成的。将小数位值转换为罗马数字有以下规则：

- 如果该值不是以 4 或 9 开头，请选择可以从输入中减去的最大值的符号，将该符号附加到结果，减去其值，然后将其余部分转换为罗马数字。
- 如果该值以 4 或 9 开头，使用 **减法形式**，表示从以下符号中减去一个符号，例如 4 是 5 (`V`) 减 1 (`I`): `IV` ，9 是 10 (`X`) 减 1 (`I`)：`IX`。仅使用以下减法形式：4 (`IV`)，9 (`IX`)，40 (`XL`)，90 (`XC`)，400 (`CD`) 和 900 (`CM`)。
- 只有 10 的次方（`I`, `X`, `C`, `M`）最多可以连续附加 3 次以代表 10 的倍数。你不能多次附加 5 (`V`)，50 (`L`) 或 500 (`D`)。如果需要将符号附加4次，请使用 **减法形式**。

给定一个整数，将其转换为罗马数字。

 

**示例 1：**

**输入：**num = 3749

**输出：** "MMMDCCXLIX"

**解释：**

```
3000 = MMM 由于 1000 (M) + 1000 (M) + 1000 (M)
 700 = DCC 由于 500 (D) + 100 (C) + 100 (C)
  40 = XL 由于 50 (L) 减 10 (X)
   9 = IX 由于 10 (X) 减 1 (I)
注意：49 不是 50 (L) 减 1 (I) 因为转换是基于小数位
```

**示例 2：**

**输入：**num = 58

**输出：**"LVIII"

**解释：**

```
50 = L
 8 = VIII
```

**示例 3：**

**输入：**num = 1994

**输出：**"MCMXCIV"

**解释：**

```
1000 = M
 900 = CM
  90 = XC
   4 = IV
```

 

**提示：**

- `1 <= num <= 3999`

这道题其实也是直接遍历，从大的开始，因为提示写的最大的只有3999

所以我们罗马数字最大的就是M 代表1000

罗列出所有的可能性，然后用if else rush过去就好了

```
class Solution {
public:
     string intToRoman(int num) {
            string s = "";
            while(num > 0)
            {
                if(num >= 1000)
                {
                    num-=1000;
                    s+="M";
                }
                else if(num >= 900)
                {
                    num-=900;
                    s+="CM";
                }
                else if(num>=500)
                {
                    num-=500;
                    s+="D";
                }
                else if(num>=400)
                {
                    num-=400;
                    s+="CD";
                }
                else if(num>=100)
                {
                    num-=100;
                    s+="C";
                }
                else if(num>=90)
                {
                    num-=90;
                    s+="XC";
                }
                else if(num>=50)
                {
                    num-=50;
                    s+="L";
                }
                else if(num>=40)
                {
                    num-=40;
                    s+="XL";
                }
                else if(num>=10)
                {
                    num-=10;
                    s+="X";
                }
                else if(num>=9)
                {
                    num-=9;
                    s+="IX";
                }
                else if(num>=5)
                {
                    num-=5;
                    s+="V";
                }
                else if(num>=4)
                {
                    num-=4;
                    s+="IV";
                }
                else if(num>=1)
                {
                    num-=1;
                    s+="I";
                }
            }
            return s;
        }
};
```

还有的解法就是构造一些键值对，来完成，但是没这个必要，思路是一样的，但是空间复杂度提升了，