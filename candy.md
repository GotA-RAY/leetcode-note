

[135. 分发糖果](https://leetcode.cn/problems/candy/)

`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 `1` 个糖果。
- 相邻两个孩子评分更高的孩子会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。

 

**示例 1：**

```
输入：ratings = [1,0,2]
输出：5
解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
```

**示例 2：**

```
输入：ratings = [1,2,2]
输出：4
解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。
```

 

**提示：**

- `n == ratings.length`
- `1 <= n <= 2 * 104`
- `0 <= ratings[i] <= 2 * 104`

 这道题，我是看了一下一些算法的博主的额视频，才开始尝试，我看下面的tag是贪心算法，就取看了一遍贪心算法

贪心算法的核心思想就是以局部最优，再到最终的全局最优

有了这个想法，开始了单休周末的一下午的尝试，心里一直安慰自己，用时多就多吧，反正以前也是打游戏度过的周末，加上猫的干扰（猫：这波我的）一下午愣是没写出来，到最后看的了别的题解才写出来

不过这个下午也不是完全没有收获，至少思考了

首先我自己的想法是，这个是找最大的连续的递增或者递减的数列，什么意思呢

来看这波

1，2，3，4

这样的输入不就是，对应的答案是

1 2 3 4相加，解释一下，第一个小朋友最少分到1个，由于题目的要求，相邻的小朋友分数高的要分到更多糖果，因此往下累加

这样我就只用统计累计最大的相邻次数

当变化方向 改变的时候，这时候我们重新从0开始累加，就好了

1，2，3，4，5，3，2，1

就算是递减，那也是一样的，算出递减的长度就好了（递减你可以倒过来看是另一头的递增）

前面1~5 累加了4次，那么就是

1+2+3+4 +4（最后的4 就是每个小朋友必须拿到糖果，保底）

然后看后面的递减了两次是吧

那么也是2+1+3 = 6这个最总输出 20

目前来看我们的思路还是没问题的

但是如果出现了

中间出现了不增不减怎么办

1，2，3，3，3，2，1

或则前一个挨着的递增数列长度小于后面的递减又该怎么办

1，6，10，8，7，5，2

你看要是还是按照我们刚刚的想法，

从1~10累加了两次那么就是1+2+1+1+1 = 6

对应的分到的糖果数量为 1 2 3

然后进入递减

递减了3次 要 1+2+3+4 = 10 

对应分到的糖果 4 3 2 1

再来看看

1 6 10 8 7 5 2

1 2 3 4 3 2 1

明显不对了嘛，10分小朋友反而比8 分的少拿

是不是不对了

后面再观察，现在是不是可以将 1 6 看成累加，10 到 2 看成递减

这样分就对了

但是我的思路就到这了，把变化趋势分为了 大于 小于 等于，中间等于的情况理不清导致最后真的没写出来

但是思路还是用的贪心算法的思路，先将一小部分的连续递增的结果算出来，在汇聚成最终得的最优解





以下是我看了题解的想法，

先看第一种，我和他的思路一致，先找一小部分的最长的单调长度，然后对这个单调长度进行计算

不同的是他在处理等于的情况时，**他将等于视作了长度为一的单调不减** 什么意思呢，他将等于和大于看成一个情况进行归类，等于的时候重置单调数列的长度为1，然后只剩了另一种情况，小于，此时他的处理是，**在之前单调不减的时候用了inc记录了单调不减的数列长度,然后在进入递减的时候使用dec记录累加的递减的数列长度， 如果这个长度大于了递增的长度，那么就再将dec自增，这样的从宏观来看意思是将上一个相邻的递增数列的最后一个，看成是我们的递减的数列开始**

```
class Solution {
public:
    int candy(vector<int>& ratings) {
        int n = ratings.size();
        int inc = 1;					// 不递减的话，任何一个数都看作是一个不递减的数列，因此										//最小的长度为1
        int dec = 0;					//递减的长度，
        int pre = 1;					//递增数列前一个小朋友拿到的糖果，最小必定是1
        int ans = 1;					//最小的答案就是1
        for(int i = 0 ;i < n-1;i++)
        {
            if(ratings[i+1] >=ratings[i])//后面的小朋友评分不小于前面的
            {
                dec = 0;				//此时进入了递增，递减的长度重置
                pre = ratings[i] == ratings[i+1] ? 1: pre+1;
                //此时pre 是当前的这个小朋友拿到糖果的数量
                //两个小朋友相等的话，那么他就跟前面的小朋友一样了
                //如果大于，就比前面的小朋友多一个，
                ans += pre;
                inc = pre;
                //此时pre就是我们的递增数列的长度
            }
            else
            {
                dec++;
                //进入了递减数列，那么递减了我们就累加我们递减的数列长度
                if(dec == inc)
                {
                	//这里就是我们刚刚提到的，上一个递增数列的长度如果和递减数列长度一样的话，就
                	//将递减数列长度再加一，将上一个递增数列的尾巴纳入我们的头部
                	//1,2,3,3,2,1
                	//进入递减数列的时候我们的最后的递增数列的长度为 1，即 i = 3时  
                	//ratings[3] = 3, ratings[4] = 2;
                	//再执行下面的dec++前我们的递减长度为1，显然我们递减长度为 3 2长度是，因此要					//加一
                	//再看例子二 1，6，10，8，7，5，2
                	//假如我们这次比较人然后自增，
                	//进入递减数列前，我们累加了三次答案，目前答案是6
                	//进入递减后累加了四次 输出答案 是16
                	// 1 2 3 4 3 2 1
                	// 1 2 5 4 3 2 1
                	// 下面的答案才是对的，下面附上了debug的变量值的图
                	// 这里可能要解释为什么前面不是已经将 rating = 10 的小朋友的糖果按3计算了嘛
                	// 怎么这里自增一个，把他归为我们递减数列，后他最后又拿到了五个呢
                	// 这里我的理解是，自增的这一个，他统计答案的时候，每一轮就会多一个，这多的这
                	// 的这一个就是给 rating = 10 的那个小朋友补上的,多了几轮补几个
                	// 看我们这 最总递减的长度是 5，而前面递减的长度为3，如果作为递减数列的头部
                	// 比作为递增数列的尾部，分到的糖果，多，那么我们5-2，是不是就刚好多了两轮了
                	// 累加，因此补给他，如果没他大就可以不用补了
                    dec++;
                }
                ans += dec;
                pre = 1;
                
            }
        }
        return ans;
    }
};
```



![image-20240512211724818](C:\Users\GOTA1\AppData\Roaming\Typora\typora-user-images\image-20240512211724818.png)

![image-20240512211818004](C:\Users\GOTA1\AppData\Roaming\Typora\typora-user-images\image-20240512211818004.png)

![image-20240512211851900](C:\Users\GOTA1\AppData\Roaming\Typora\typora-user-images\image-20240512211851900.png)





解法二：遍历两次

可以说是另一个在贪心的思路，刚刚是想找出最长的连续单调，作为局部，那么这次局部，是先从左到右，遍历一遍，如果左边的数小于右边的，将右边在左边的基础上加一 ，然后再从右到左遍历一遍如果左边的大于右边的，就在右边的基础上加一。

这个思路的难点我觉得是为什么第一次是从前向后遍历，而第二次是从后向前遍历

原因在于，我们大的那个数，要基于小的那个数，分到的糖果加一

如果从左边遍历 5，4，3，2，1    

初始的时候，每个小朋友拿到的糖果是1，

那么我们candynums 初始值为 1，1，1，1，1

从左到右，遍历，i>i+1,是 candynums[i] = candynums[i+1] +1，

然后我们此时先从最大的更新，小的那些还是初始值，我们只能在初始值上更新，所以是 错的

对于这个我们一定要从小的遍历，如果左边的小于右边，我们从左边开始，如果右边小于左边，右边开始



第二遍遍历的时候如果candynums[i] > 第一遍的candynums[i]的话，要采用更大的那个，应为大的那个才能保证比相邻的多

```
class Solution {
public:
    int candy(vector<int>& ratings) {
        int n = ratings.size();
        if(n==1)
        {
            return 1;
        }
        int ans = 0;
        vector<int>candyNums(n,1);
        for(int i = 1 ;i < n;i++)
        {
            if(ratings[i] > ratings[i-1])
            {
                candyNums[i] = candyNums[i-1] +1;
            }
        }
        for(int i = n-2;i>-1;i--)
        {
            if(ratings[i] > ratings[i+1])
            {
                candyNums[i] = max(candyNums[i],candyNums[i+1]+1);
            }
            ans+=candyNums[i];
        }
        ans+=candyNums[n-1];

        return ans;
    }
};
```

